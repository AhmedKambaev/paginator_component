// @flow
// $FlowFixMe
import React from 'react';
import {
  Button,
  Container,
  NextButton,
  ButtonsList,
  PrevButton,
} from './styled';

type PaginateProps = {
  data: Array<mixed>,
  limit: number,
  Component: any,
}

const chunkArray = (array, chunkSize) => {
  const result = [];
  const maxLength = array.length;

  for (let item = 0; item < maxLength; item += chunkSize) {
    result.push(array.slice(item, item + chunkSize));
  }

  return result;
};

class Paginate extends React.Component<PaginateProps> {
  constructor() {
    super();
    // $FlowFixMe
    this.state = {
      paginate: [],
      active: 0,
      dataPaginate: [],
      dataState: [],
    };
  }

  componentDidMount() {
    // $FlowFixMe
    const { dataState } = this.state;
    const { data } = this.props;
    // $FlowFixMe
    if (data.data) {
      if (data.data.length !== dataState.length) {
        // $FlowFixMe
        this.setState({ dataState: data.data });
      }
    }
    this.setPaginate();
  }

  componentDidUpdate() {
    // $FlowFixMe
    const { dataState } = this.state;
    const { data } = this.props;
    console.log(data, dataState);
    // $FlowFixMe
    if (data.length > 0) {
      if (data[0].data.length !== dataState.length) {
        // $FlowFixMe
        this.setState({ dataState: data[0].data });
        this.setPaginate();
      }
    }
  }

  setPaginate(): void {
    const { data, limit } = this.props;
    if (Array.isArray(data)) {
      let size = 0;
      let limitState = limit;
      if (limit === 0) {
        limitState = 1;
      }
      console.log(data);
      const filtArray = chunkArray(data.map((item, i) => {
        console.log('');
        return {
          ...item,
          idxPaginate: i,
        };
      }), limitState);

      size = filtArray.length;
      // $FlowFixMe
      this.setState({
        paginate: data.slice(0, size).map((item, i) => ({
          ...item,
          idxPaginate: i,
        })),
        dataPaginate: filtArray,
      });
    } else {
      throw new Error('"data" must be an array!');
    }
  }

  togglePaginate = (idx: any) => {
    // $FlowFixMe
    this.setState({
      active: idx,
    });
  }

  render() {
    // $FlowFixMe
    const { paginate, active, dataPaginate } = this.state;
    // $FlowFixMe
    const { Component, data } = this.props;
    console.log(dataPaginate);
    return (
      <Container>
        <ButtonsList>
          {
            active > 0 && (
              <PrevButton
                onClick={() => this.togglePaginate(active - 1)}
              >
                Prev
              </PrevButton>
            )
          }
          {
            paginate.map(item => (
              <Button
                first={item.idxPaginate === 0 && active === 0}
                last={item.idxPaginate === active && active + 1 === data.length}
                type="button"
                active={active === item.idxPaginate}
                key={item.idxPaginate}
                onClick={() => this.togglePaginate(item.idxPaginate)}
              >
                { item.idxPaginate + 1 }
              </Button>
            ))
          }
          {
            active + 1 < dataPaginate.length && (
              <NextButton
                onClick={() => this.togglePaginate(active + 1)}
              >
                Next
              </NextButton>
            )
          }
        </ButtonsList>
        {
          dataPaginate.length > 0 ? dataPaginate[active].map((item, i) => (
            <Component key={item.idxPaginate || i} {...item} />
          )) : null
        }
      </Container>
    );
  }
}

export { Paginate };
